{"mappings":"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","sources":["<anon>","src/script.js"],"sourcesContent":["\"use strict\";\nconst modal = document.querySelector(\".modal\");\nconst overlay = document.querySelector(\".overlay\");\nconst btnCloseModal = document.querySelector(\".btn--close-modal\");\nconst btnsOpenModal = document.querySelectorAll(\".btn--show-modal\");\nconst btnScrollTo = document.querySelector(`.btn--scroll-to`);\nconst section1 = document.querySelector(`#section--1`);\nconst nav = document.querySelector(`.nav`);\nconst tabs = document.querySelectorAll(`.operations__tab`);\nconst tabsContainers = document.querySelector(`.operations__tab-container`);\nconst tabsContent = document.querySelectorAll(`.operations__content`);\nconst header = document.querySelector(`.header`);\n///////////////////////////////////////\n// Modal window // Модальное окно\nconst openModal = (e)=>{\n    // предотвращение прокрутки страницы в самый верх, при нажатии на кнопку логина\n    e.preventDefault();\n    modal.classList.remove(\"hidden\");\n    overlay.classList.remove(\"hidden\");\n};\nconst closeModal = ()=>{\n    modal.classList.add(\"hidden\");\n    overlay.classList.add(\"hidden\");\n};\n// for (let i = 0; i < btnsOpenModal.length; i++)\n//   btnsOpenModal[i].addEventListener('click', openModal);\n// Аналог записи сверху\n// Подключение кнопки в нижнем колонтитуле\nbtnsOpenModal.forEach((btn)=>btn.addEventListener(`click`, openModal));\nbtnCloseModal.addEventListener(\"click\", closeModal);\noverlay.addEventListener(\"click\", closeModal);\ndocument.addEventListener(\"keydown\", (e)=>{\n    if (e.key === \"Escape\" && !modal.classList.contains(\"hidden\")) closeModal();\n});\n///////////////////////////////////////\n// Implementing Smooth Scrolling // Реализация плавной прокрутки\n// Кнопка скрола\nbtnScrollTo.addEventListener(`click`, (e)=>{\n    const s1coords = section1.getBoundingClientRect();\n    // console.log(s1coords);\n    // console.log(e.target.getBoundingClientRect());\n    // console.log(`Current scroll (X/Y)`, window.pageXOffset, window.pageYOffset);\n    // console.log(\n    //   `height/width viewport`,\n    //   document.documentElement.clientHeight,\n    //   document.documentElement.clientWidth\n    // );\n    // Scrolling\n    // window.scrollTo(\n    //   s1coords.left + window.pageXOffset,\n    //   s1coords.top + window.pageYOffset\n    // );\n    // window.scrollTo({\n    //   left: s1coords.left + window.pageXOffset,\n    //   top: s1coords.top + window.pageYOffset,\n    //   behavior: `smooth`,\n    // });\n    section1.scrollIntoView({\n        behavior: `smooth`\n    });\n});\n///////////////////////////////////////\n// Page navigation // постраничная новигация\n// document.querySelectorAll(`.nav__link`).forEach(function (el) {\n//   // Функция обратного высзова в функ. обрат. вызова\n//   el.addEventListener(`click`, function (e) {\n//     e.preventDefault();\n//     const id = this.getAttribute(`href`);\n//     console.log(id); // в зависимости от элемента, на который нажали // #section--3\n//     document.querySelector(id).scrollIntoView({ behavior: `smooth` });\n//   });\n// });\n// Делегирования событий\n// 1. Добавить слушателя событий к общему родительскому элементу\n// Add event listener to common parent element\n// 2. Определить, какой элемент вызвал событие\n// Determine what element originated the event\ndocument.querySelector(`.nav__links`).addEventListener(`click`, (e)=>{\n    e.preventDefault();\n    // Стратегия подбора\n    // проверка, содеражит ли целевой элемент класс, который указан в параметре\n    if (e.target.classList.contains(`nav__link`)) {\n        const id = e.target.getAttribute(`href`);\n        document.querySelector(id).scrollIntoView({\n            behavior: `smooth`\n        });\n    }\n});\n///////////////////////////////////////\n// create tab switching // создать переключение вкладок\n// Так делать нельзя\n// tabs.forEach(t => t.addEventListener(`click`, () => console.log(`TAB`)));\n// замедляет страницу, если будет много вкладок, получится копия для каждой вкладки\n// Используем делегирование событий // Для этого метода важно прекреплять обработчик\n// событий на общем родительском элементе\ntabsContainers.addEventListener(`click`, (e)=>{\n    // Обнаруживается ближайшая вкладка операции(на котторую нажали)\n    // Метод Element.closest() возвращает ближайший родительский элемент (или сам элемент)\n    const clicked = e.target.closest(`.operations__tab`);\n    // console.log(clicked);\n    // Guard clause // защитная оговорка\n    // игнорирование щелчков вне области `.operations__tab`\n    // когда есть Null(ошибка), то !clicked значение станет истеннной\n    // и последующий код не будет выполнен, если clicked тру,\n    // то возврат не будет выполнен и последующий код будет выполнен\n    if (!clicked) return;\n    // Удалить активный класс\n    tabs.forEach((t)=>t.classList.remove(`operations__tab--active`));\n    tabsContent.forEach((c)=>c.classList.remove(`operations__content--active`));\n    // Активная вкладка\n    clicked.classList.add(`operations__tab--active`);\n    // Активировать область содержимого\n    // console.log(clicked.dataset.tab);\n    document.querySelector(`.operations__content--${clicked.dataset.tab}`).classList.add(`operations__content--active`);\n});\n// Эффект затухания меню\nconst handleHover = function(e) {\n    // const handleHover = e => {\n    // console.log(this, e.currentTarget);\n    // console.log(this);\n    if (e.target.classList.contains(`nav__link`)) {\n        const link = e.target;\n        const siblings = link.closest(`.nav`).querySelectorAll(`.nav__link`);\n        const logo = link.closest(`.nav`).querySelector(`img`);\n        // Изменение прозрачности\n        siblings.forEach((el)=>{\n            if (el !== link) el.style.opacity = this;\n        });\n        logo.style.opacity = this;\n    }\n};\n/////////////////////////////////////////////////////////\n// Sticky navigation: intersection observer API\n// Липкая навигация: API наблюдателя пересечений\nconst navHeight = nav.getBoundingClientRect().height;\nconst stickyNav = (entries)=>{\n    const [entry] = entries;\n    if (!entry.isIntersecting) nav.classList.add(`sticky`);\n    else nav.classList.remove(`sticky`);\n};\nconst headerObserver = new IntersectionObserver(stickyNav, {\n    root: null,\n    threshold: 0,\n    rootMargin: `-${navHeight}px`\n});\nheaderObserver.observe(header);\n// Reveal sections // Раскрыть разделы\nconst allSection = document.querySelectorAll(`.section`);\nconst revealSection = (entries, observer)=>{\n    const [entry] = entries;\n    if (!entry.isIntersecting) return;\n    entry.target.classList.remove(`section--hidden`);\n    observer.unobserve(entry.target);\n};\nconst sectionObserver = new IntersectionObserver(revealSection, {\n    root: null,\n    threshold: 0.15\n});\nallSection.forEach((section)=>{\n    sectionObserver.observe(section);\n    section.classList.add(`section--hidden`);\n});\n///////////////////////////////////////\n// Lazy loading images // ленивая загрузка изображений\n// выбираем все изображения, которые имеют свойство data-src(дэта сорс)\n// const imgTargets = document.querySelectorAll(`img[data-src]`);\nconst imgTargets = document.querySelectorAll(`img[srcset]`);\nconst loadImg = (entries, observer)=>{\n    const [entry] = entries;\n    if (!entry.isIntersecting) return;\n    // Replace src with data-src // Заменить src на data-src\n    entry.target.src = entry.target.dataset.src;\n    entry.target.addEventListener(`load`, ()=>{\n        entry.target.classList.remove(`lazy-img`);\n    });\n    observer.unobserve(entry.target);\n};\nconst imgObserver = new IntersectionObserver(loadImg, {\n    root: null,\n    threshold: 0,\n    rootMargin: `200px`\n});\nimgTargets.forEach((img)=>imgObserver.observe(img));\n///////////////////////////////////////\n// slider // слайдер\nconst slider = ()=>{\n    const slides = document.querySelectorAll(`.slide`);\n    const btnLeft = document.querySelector(`.slider__btn--left`);\n    const btnRight = document.querySelector(`.slider__btn--right`);\n    const dotContainer = document.querySelector(`.dots`);\n    let curSlide = 0;\n    const maxSlide = slides.length;\n    // function\n    const createDots = ()=>{\n        slides.forEach((_, i)=>{\n            dotContainer.insertAdjacentHTML(`beforeend`, `<button class=\"dots__dot\" data-slide=\"${i}\"></button>`);\n        });\n    };\n    const activateDot = (slide)=>{\n        document.querySelectorAll(`.dots__dot`).forEach((dot)=>dot.classList.remove(`dots__dot--active`));\n        document.querySelector(`.dots__dot[data-slide=\"${slide}\"]`).classList.add(`dots__dot--active`);\n    };\n    const goToSlide = (slide)=>{\n        slides.forEach((s, i)=>s.style.transform = `translateX(${100 * (i - slide)}%)`);\n    };\n    // Next slide\n    const nextSlide = ()=>{\n        if (curSlide === maxSlide - 1) curSlide = 0;\n        else curSlide++;\n        goToSlide(curSlide);\n        activateDot(curSlide);\n    };\n    const prevSlide = ()=>{\n        if (curSlide === 0) curSlide = maxSlide - 1;\n        else curSlide--;\n        goToSlide(curSlide);\n        activateDot(curSlide);\n    };\n    const init = ()=>{\n        goToSlide(0);\n        createDots();\n        activateDot(0);\n    };\n    init();\n    // Event handlers\n    btnRight.addEventListener(`click`, nextSlide);\n    btnLeft.addEventListener(`click`, prevSlide);\n    document.addEventListener(`keydown`, (e)=>{\n        if (e.key === `ArrowLeft`) prevSlide();\n        e.key === `ArrowRight` && nextSlide();\n    });\n    dotContainer.addEventListener(`click`, (e)=>{\n        if (e.target.classList.contains(`dots__dot`)) {\n            const { slide } = e.target.dataset;\n            goToSlide(slide);\n            activateDot(slide);\n        }\n    });\n};\nslider();\n///////////////////////////////////////\n// // Передача \"аргумента\" в обработчик\n// Событие mouseover запускается, Element когда указывающее устройство\n// (например, мышь или трекпад) используется для перемещения курсора\n// на элемент или один из его дочерних элементов.\n// addEventListener во втором параметре всегда ожидает функцию,\n// поэтому используется функция обратного вызова.\n// метод связывания // Метод bind() создаёт новую функцию,\n// которая при вызове устанавливает в качестве контекста выполнения this,\n// предоставленное значение. В метод также передаётся набор аргументов,\n// которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.\nnav.addEventListener(`mouseover`, handleHover.bind(0.4));\n// Событие mouseout запускается, Element когда указывающее устройство (обычно мышь)\n// используется для перемещения курсора таким образом, чтобы он больше\n// не содержался внутри элемента или одного из его дочерних элементов.\nnav.addEventListener(`mouseout`, handleHover.bind(1)); /////////////////////////////////////////////////////////////\n // Выбор, создание и удаление элементов\n // const message = document.createElement(`div`);\n // message.classList.add(`cookie-message`);\n // // message.textContent = `We use cookied for improved functionalyty and analytics`;\n // message.innerHTML = `\n // We use cookied for improved functionalyty and analytics.\n // <buttton class=\"btn btn--close-cookie\">Got it!</button>\n // `;\n // // Метод Element.prepend()вставляет набор Nodeобъектов\n // или строковых объектов перед первым дочерним элементом Element.\n // Строковые объекты вставляются как эквивалентные Text узлы.\n // // header.prepend(message);\n // // Метод Element.append() вставляет узлы или строки с текстом\n // в конец Element. Строки с текстом вставляются как текстовое содержимое.\n // header.append(message);\n // // Delete elements\n // document\n //   .querySelector(`.btn--close-cookie`)\n //   .addEventListener(`click`, function () {\n //     // message.remove();\n //     message.parentElement.removeChild(message);\n //   });\n // message.style.backgroundColor = `#37383d`;\n // message.style.width = `103%`;\n // // Изменение цвета\n // document.documentElement.style.setProperty(`--color-primary`, `orangered`);\n // // изменение размера\n // message.style.height =\n //   Number.parseFloat(getComputedStyle(message).height) + 40 + `px`;\n\n//# sourceMappingURL=index.c9289794.js.map\n","'use strict';\r\n\r\nconst modal = document.querySelector('.modal');\r\nconst overlay = document.querySelector('.overlay');\r\nconst btnCloseModal = document.querySelector('.btn--close-modal');\r\nconst btnsOpenModal = document.querySelectorAll('.btn--show-modal');\r\nconst btnScrollTo = document.querySelector(`.btn--scroll-to`);\r\nconst section1 = document.querySelector(`#section--1`);\r\nconst nav = document.querySelector(`.nav`);\r\nconst tabs = document.querySelectorAll(`.operations__tab`);\r\nconst tabsContainers = document.querySelector(`.operations__tab-container`);\r\nconst tabsContent = document.querySelectorAll(`.operations__content`);\r\nconst header = document.querySelector(`.header`);\r\n\r\n///////////////////////////////////////\r\n// Modal window // Модальное окно\r\n\r\nconst openModal = e => {\r\n  // предотвращение прокрутки страницы в самый верх, при нажатии на кнопку логина\r\n  e.preventDefault();\r\n  modal.classList.remove('hidden');\r\n  overlay.classList.remove('hidden');\r\n};\r\n\r\nconst closeModal = () => {\r\n  modal.classList.add('hidden');\r\n  overlay.classList.add('hidden');\r\n};\r\n\r\n// for (let i = 0; i < btnsOpenModal.length; i++)\r\n//   btnsOpenModal[i].addEventListener('click', openModal);\r\n// Аналог записи сверху\r\n// Подключение кнопки в нижнем колонтитуле\r\nbtnsOpenModal.forEach(btn => btn.addEventListener(`click`, openModal));\r\n\r\nbtnCloseModal.addEventListener('click', closeModal);\r\noverlay.addEventListener('click', closeModal);\r\n\r\ndocument.addEventListener('keydown', e => {\r\n  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {\r\n    closeModal();\r\n  }\r\n});\r\n\r\n///////////////////////////////////////\r\n// Implementing Smooth Scrolling // Реализация плавной прокрутки\r\n// Кнопка скрола\r\nbtnScrollTo.addEventListener(`click`, e => {\r\n  const s1coords = section1.getBoundingClientRect();\r\n  // console.log(s1coords);\r\n\r\n  // console.log(e.target.getBoundingClientRect());\r\n\r\n  // console.log(`Current scroll (X/Y)`, window.pageXOffset, window.pageYOffset);\r\n\r\n  // console.log(\r\n  //   `height/width viewport`,\r\n  //   document.documentElement.clientHeight,\r\n  //   document.documentElement.clientWidth\r\n  // );\r\n\r\n  // Scrolling\r\n  // window.scrollTo(\r\n  //   s1coords.left + window.pageXOffset,\r\n  //   s1coords.top + window.pageYOffset\r\n  // );\r\n\r\n  // window.scrollTo({\r\n  //   left: s1coords.left + window.pageXOffset,\r\n  //   top: s1coords.top + window.pageYOffset,\r\n  //   behavior: `smooth`,\r\n  // });\r\n\r\n  section1.scrollIntoView({ behavior: `smooth` });\r\n});\r\n\r\n///////////////////////////////////////\r\n// Page navigation // постраничная новигация\r\n\r\n// document.querySelectorAll(`.nav__link`).forEach(function (el) {\r\n//   // Функция обратного высзова в функ. обрат. вызова\r\n//   el.addEventListener(`click`, function (e) {\r\n//     e.preventDefault();\r\n//     const id = this.getAttribute(`href`);\r\n//     console.log(id); // в зависимости от элемента, на который нажали // #section--3\r\n//     document.querySelector(id).scrollIntoView({ behavior: `smooth` });\r\n//   });\r\n// });\r\n\r\n// Делегирования событий\r\n// 1. Добавить слушателя событий к общему родительскому элементу\r\n// Add event listener to common parent element\r\n// 2. Определить, какой элемент вызвал событие\r\n// Determine what element originated the event\r\n\r\ndocument.querySelector(`.nav__links`).addEventListener(`click`, e => {\r\n  e.preventDefault();\r\n  // Стратегия подбора\r\n  // проверка, содеражит ли целевой элемент класс, который указан в параметре\r\n  if (e.target.classList.contains(`nav__link`)) {\r\n    const id = e.target.getAttribute(`href`);\r\n    document.querySelector(id).scrollIntoView({ behavior: `smooth` });\r\n  }\r\n});\r\n\r\n///////////////////////////////////////\r\n// create tab switching // создать переключение вкладок\r\n\r\n// Так делать нельзя\r\n// tabs.forEach(t => t.addEventListener(`click`, () => console.log(`TAB`)));\r\n// замедляет страницу, если будет много вкладок, получится копия для каждой вкладки\r\n// Используем делегирование событий // Для этого метода важно прекреплять обработчик\r\n// событий на общем родительском элементе\r\ntabsContainers.addEventListener(`click`, e => {\r\n  // Обнаруживается ближайшая вкладка операции(на котторую нажали)\r\n  // Метод Element.closest() возвращает ближайший родительский элемент (или сам элемент)\r\n  const clicked = e.target.closest(`.operations__tab`);\r\n  // console.log(clicked);\r\n  // Guard clause // защитная оговорка\r\n  // игнорирование щелчков вне области `.operations__tab`\r\n  // когда есть Null(ошибка), то !clicked значение станет истеннной\r\n  // и последующий код не будет выполнен, если clicked тру,\r\n  // то возврат не будет выполнен и последующий код будет выполнен\r\n  if (!clicked) return;\r\n\r\n  // Удалить активный класс\r\n  tabs.forEach(t => t.classList.remove(`operations__tab--active`));\r\n  tabsContent.forEach(c => c.classList.remove(`operations__content--active`));\r\n\r\n  // Активная вкладка\r\n  clicked.classList.add(`operations__tab--active`);\r\n\r\n  // Активировать область содержимого\r\n  // console.log(clicked.dataset.tab);\r\n  document\r\n    .querySelector(`.operations__content--${clicked.dataset.tab}`)\r\n    .classList.add(`operations__content--active`);\r\n});\r\n\r\n// Эффект затухания меню\r\nconst handleHover = function (e) {\r\n  // const handleHover = e => {\r\n  // console.log(this, e.currentTarget);\r\n  // console.log(this);\r\n  if (e.target.classList.contains(`nav__link`)) {\r\n    const link = e.target;\r\n    const siblings = link.closest(`.nav`).querySelectorAll(`.nav__link`);\r\n    const logo = link.closest(`.nav`).querySelector(`img`);\r\n\r\n    // Изменение прозрачности\r\n    siblings.forEach(el => {\r\n      if (el !== link) el.style.opacity = this;\r\n    });\r\n    logo.style.opacity = this;\r\n  }\r\n};\r\n\r\n/////////////////////////////////////////////////////////\r\n// Sticky navigation: intersection observer API\r\n// Липкая навигация: API наблюдателя пересечений\r\n\r\nconst navHeight = nav.getBoundingClientRect().height;\r\n\r\nconst stickyNav = entries => {\r\n  const [entry] = entries;\r\n  if (!entry.isIntersecting) nav.classList.add(`sticky`);\r\n  else nav.classList.remove(`sticky`);\r\n};\r\n\r\nconst headerObserver = new IntersectionObserver(stickyNav, {\r\n  root: null,\r\n  threshold: 0,\r\n  rootMargin: `-${navHeight}px`,\r\n});\r\nheaderObserver.observe(header);\r\n\r\n// Reveal sections // Раскрыть разделы\r\nconst allSection = document.querySelectorAll(`.section`);\r\n\r\nconst revealSection = (entries, observer) => {\r\n  const [entry] = entries;\r\n\r\n  if (!entry.isIntersecting) return;\r\n\r\n  entry.target.classList.remove(`section--hidden`);\r\n  observer.unobserve(entry.target);\r\n};\r\n\r\nconst sectionObserver = new IntersectionObserver(revealSection, {\r\n  root: null,\r\n  threshold: 0.15,\r\n});\r\n\r\nallSection.forEach(section => {\r\n  sectionObserver.observe(section);\r\n  section.classList.add(`section--hidden`);\r\n});\r\n\r\n///////////////////////////////////////\r\n// Lazy loading images // ленивая загрузка изображений\r\n// выбираем все изображения, которые имеют свойство data-src(дэта сорс)\r\n// const imgTargets = document.querySelectorAll(`img[data-src]`);\r\nconst imgTargets = document.querySelectorAll(`img[srcset]`);\r\n\r\nconst loadImg = (entries, observer) => {\r\n  const [entry] = entries;\r\n\r\n  if (!entry.isIntersecting) return;\r\n\r\n  // Replace src with data-src // Заменить src на data-src\r\n  entry.target.src = entry.target.dataset.src;\r\n\r\n  entry.target.addEventListener(`load`, () => {\r\n    entry.target.classList.remove(`lazy-img`);\r\n  });\r\n\r\n  observer.unobserve(entry.target);\r\n};\r\n\r\nconst imgObserver = new IntersectionObserver(loadImg, {\r\n  root: null,\r\n  threshold: 0,\r\n  rootMargin: `200px`,\r\n});\r\n\r\nimgTargets.forEach(img => imgObserver.observe(img));\r\n\r\n///////////////////////////////////////\r\n// slider // слайдер\r\nconst slider = () => {\r\n  const slides = document.querySelectorAll(`.slide`);\r\n  const btnLeft = document.querySelector(`.slider__btn--left`);\r\n  const btnRight = document.querySelector(`.slider__btn--right`);\r\n  const dotContainer = document.querySelector(`.dots`);\r\n\r\n  let curSlide = 0;\r\n  const maxSlide = slides.length;\r\n\r\n  // function\r\n\r\n  const createDots = () => {\r\n    slides.forEach((_, i) => {\r\n      dotContainer.insertAdjacentHTML(\r\n        `beforeend`,\r\n        `<button class=\"dots__dot\" data-slide=\"${i}\"></button>`\r\n      );\r\n    });\r\n  };\r\n\r\n  const activateDot = slide => {\r\n    document\r\n      .querySelectorAll(`.dots__dot`)\r\n      .forEach(dot => dot.classList.remove(`dots__dot--active`));\r\n\r\n    document\r\n      .querySelector(`.dots__dot[data-slide=\"${slide}\"]`)\r\n      .classList.add(`dots__dot--active`);\r\n  };\r\n\r\n  const goToSlide = slide => {\r\n    slides.forEach(\r\n      (s, i) => (s.style.transform = `translateX(${100 * (i - slide)}%)`)\r\n    );\r\n  };\r\n\r\n  // Next slide\r\n  const nextSlide = () => {\r\n    if (curSlide === maxSlide - 1) {\r\n      curSlide = 0;\r\n    } else {\r\n      curSlide++;\r\n    }\r\n\r\n    goToSlide(curSlide);\r\n    activateDot(curSlide);\r\n  };\r\n\r\n  const prevSlide = () => {\r\n    if (curSlide === 0) {\r\n      curSlide = maxSlide - 1;\r\n    } else {\r\n      curSlide--;\r\n    }\r\n    goToSlide(curSlide);\r\n    activateDot(curSlide);\r\n  };\r\n\r\n  const init = () => {\r\n    goToSlide(0);\r\n    createDots();\r\n    activateDot(0);\r\n  };\r\n  init();\r\n\r\n  // Event handlers\r\n  btnRight.addEventListener(`click`, nextSlide);\r\n  btnLeft.addEventListener(`click`, prevSlide);\r\n\r\n  document.addEventListener(`keydown`, e => {\r\n    if (e.key === `ArrowLeft`) prevSlide();\r\n    e.key === `ArrowRight` && nextSlide();\r\n  });\r\n\r\n  dotContainer.addEventListener(`click`, e => {\r\n    if (e.target.classList.contains(`dots__dot`)) {\r\n      const { slide } = e.target.dataset;\r\n      goToSlide(slide);\r\n      activateDot(slide);\r\n    }\r\n  });\r\n};\r\nslider();\r\n\r\n///////////////////////////////////////\r\n// // Передача \"аргумента\" в обработчик\r\n\r\n// Событие mouseover запускается, Element когда указывающее устройство\r\n// (например, мышь или трекпад) используется для перемещения курсора\r\n// на элемент или один из его дочерних элементов.\r\n// addEventListener во втором параметре всегда ожидает функцию,\r\n// поэтому используется функция обратного вызова.\r\n// метод связывания // Метод bind() создаёт новую функцию,\r\n// которая при вызове устанавливает в качестве контекста выполнения this,\r\n// предоставленное значение. В метод также передаётся набор аргументов,\r\n// которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.\r\nnav.addEventListener(`mouseover`, handleHover.bind(0.4));\r\n\r\n// Событие mouseout запускается, Element когда указывающее устройство (обычно мышь)\r\n// используется для перемещения курсора таким образом, чтобы он больше\r\n// не содержался внутри элемента или одного из его дочерних элементов.\r\nnav.addEventListener(`mouseout`, handleHover.bind(1));\r\n\r\n/////////////////////////////////////////////////////////////\r\n// Выбор, создание и удаление элементов\r\n\r\n// const message = document.createElement(`div`);\r\n// message.classList.add(`cookie-message`);\r\n// // message.textContent = `We use cookied for improved functionalyty and analytics`;\r\n// message.innerHTML = `\r\n// We use cookied for improved functionalyty and analytics.\r\n// <buttton class=\"btn btn--close-cookie\">Got it!</button>\r\n// `;\r\n\r\n// // Метод Element.prepend()вставляет набор Nodeобъектов\r\n// или строковых объектов перед первым дочерним элементом Element.\r\n// Строковые объекты вставляются как эквивалентные Text узлы.\r\n// // header.prepend(message);\r\n// // Метод Element.append() вставляет узлы или строки с текстом\r\n// в конец Element. Строки с текстом вставляются как текстовое содержимое.\r\n// header.append(message);\r\n\r\n// // Delete elements\r\n// document\r\n//   .querySelector(`.btn--close-cookie`)\r\n//   .addEventListener(`click`, function () {\r\n//     // message.remove();\r\n//     message.parentElement.removeChild(message);\r\n//   });\r\n\r\n// message.style.backgroundColor = `#37383d`;\r\n// message.style.width = `103%`;\r\n\r\n// // Изменение цвета\r\n// document.documentElement.style.setProperty(`--color-primary`, `orangered`);\r\n\r\n// // изменение размера\r\n// message.style.height =\r\n//   Number.parseFloat(getComputedStyle(message).height) + 40 + `px`;\r\n"],"names":["modal","document","querySelector","overlay","btnCloseModal","btnsOpenModal","querySelectorAll","btnScrollTo","section1","nav","tabs","tabsContainers","tabsContent","header","openModal","e","preventDefault","classList","remove","closeModal","add","forEach","btn","addEventListener","key","contains","getBoundingClientRect","scrollIntoView","behavior","target","id","getAttribute","clicked","closest","t","c","dataset","tab","handleHover","link","siblings","logo","el","style","opacity","navHeight","height","headerObserver","IntersectionObserver","entries","entry","isIntersecting","root","threshold","rootMargin","observe","allSection","sectionObserver","observer","unobserve","section","imgTargets","imgObserver","src","img","slider","slides","btnLeft","btnRight","dotContainer","curSlide","maxSlide","length","activateDot","slide","dot","goToSlide","s","i","transform","nextSlide","prevSlide","_","insertAdjacentHTML","bind"],"version":3,"file":"index.c9289794.js.map"}